package project_euler

/**
 * Problem 61:
 * Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:
 *
 * Triangle      P3(n)=n(n+1)/2     1, 3, 6, 10, 15, ...
 * Square        P4(n)=n^2          1, 4, 9, 16, 25, ...
 * Pentagonal    P5(n)=n(3n−1)/2    1, 5, 12, 22, 35, ...
 * Hexagonal     P6(n)=n(2n−1)      1, 6, 15, 28, 45, ...
 * Heptagonal    P7(n)=n(5n−3)/2    1, 7, 18, 34, 55, ...
 * Octagonal     P8(n)=n(3n−2)      1, 8, 21, 40, 65, ...
 *
 * The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
 *
 * 1. The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
 * 2. Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different number in the set.
 * 3. This is the only set of 4-digit numbers with this property.
 *
 * Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type:
 * triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.
 *
 * 問題 61:
 * 三角数, 四角数, 五角数, 六角数, 七角数, 八角数は多角数であり, それぞれ以下の式で生成される.
 *
 * 三角数    P3,n=n(n+1)/2     1, 3, 6, 10, 15, ...
 * 四角数    P4,n=n^2          1, 4, 9, 16, 25, ...
 * 五角数    P5,n=n(3n-1)/2    1, 5, 12, 22, 35, ...
 * 六角数    P6,n=n(2n-1)      1, 6, 15, 28, 45, ...
 * 七角数    P7,n=n(5n-3)/2    1, 7, 18, 34, 55, ...
 * 八角数    P8,n=n(3n-2)      1, 8, 21, 40, 65, ...
 *
 * 3つの4桁の数の順番付きの集合 (8128, 2882, 8281) は以下の面白い性質を持つ.
 *
 * 1. この集合は巡回的である. 最後の数も含めて, 各数の後半2桁は次の数の前半2桁と一致する
 * 2. それぞれ多角数である: 三角数 (P3,127=8128), 四角数 (P4,91=8281), 五角数 (P5,44=2882) がそれぞれ別の数字で集合に含まれている
 * 3. 4桁の数の組で上の2つの性質をもつはこの組だけである.
 *
 * 三角数, 四角数, 五角数, 六角数, 七角数, 八角数が全て表れる6つの巡回する4桁の数からなる唯一の順序集合の和を求めよ.
 */
object P061 {
  import commons._

  val ps = List(
    from(1).map { n => n * (n + 1) / 2 },
    from(1).map { n => n * n },
    from(1).map { n => n * (3 * n - 1) / 2 },
    from(1).map { n => n * (2 * n - 1) },
    from(1).map { n => n * (5 * n - 3) / 2 },
    from(1).map { n => n * (3 * n - 2) }
  )

  def permutations(ls: List[List[Long]]): List[List[Long]] = ls match {
    case Nil => List(Nil)
    case xs :: ys => xs.flatMap { x => permutations(ys).map { x :: _ } }
  }

  def isCyclic(ls: List[Long]): Boolean = {
    def hasNext(x: Long, xs: List[Long]): Boolean = xs match {
      case Nil => true
      case _ => xs.filter { n => x % 100 == n / 100 } match {
        case Nil => false
        case y :: Nil => hasNext(y, xs.diff(List(y)))
        case ys => ys.exists { n => hasNext(n, xs.diff(List(n))) }
      }
    }

    def hasPrev(x: Long, xs: List[Long]): Boolean = xs match {
      case Nil => true
      case _ => xs.filter { n => x / 100 == n % 100 } match {
        case Nil => false
        case y :: Nil => hasPrev(y, xs.diff(List(y)))
        case ys => ys.exists { n => hasPrev(n, xs.diff(List(n))) }
      }
    }

    ls match {
      case Nil => true
      case _ => ls.exists { n => val xs = ls.diff(List(n)); hasNext(n, xs) && hasPrev(n, xs) }
    }
  }

  def solve(n: Int): Long = {
    val ls = ps.map { _.dropWhile { _ < 1000 }.takeWhile { _ < 10000 }.filter { k => k / 100 >= 10 && k % 100 >= 10 }.toList }.take(n)
    permutations(ls).filter { xs => isCyclic(xs) } match {
      case Nil => 0
      case xs :: _ => xs.sum
    }
  }
}
